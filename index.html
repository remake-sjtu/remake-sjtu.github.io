<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="见山还是山">
<meta property="og:type" content="website">
<meta property="og:title" content="源之居">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="源之居">
<meta property="og:description" content="见山还是山">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="FY-Zhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>源之居</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">源之居</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/26/CS144/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="FY-Zhu">
      <meta itemprop="description" content="见山还是山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="源之居">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/26/CS144/" class="post-title-link" itemprop="url">CS144实验记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-26 21:22:38" itemprop="dateCreated datePublished" datetime="2023-06-26T21:22:38+08:00">2023-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-10 19:33:06" itemprop="dateModified" datetime="2023-12-10T19:33:06+08:00">2023-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="启程"><a href="#启程" class="headerlink" title="启程"></a>启程</h1><p>配环境</p>
<p>vscode+remote-ssh+云服务器centos8开发</p>
<p>本想写2023年的新版lab，但是看了看要用g++20编译，试了试更新g++太难，放弃了，期间还删掉了g++，还好服务器有备份可以回滚。</p>
<p>推荐使用 <span class="exturl" data-url="aHR0cHM6Ly9rYW5neXVwbC5naXRlZS5pby9jczE0NC5naXRodWIuaW8v">https://kangyupl.gitee.io/cs144.github.io/<i class="fa fa-external-link-alt"></i></span> 网站镜像备份，g++8编译就可以。</p>
<p>代码也是采用 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20va2FuZ3l1cGwvc3Bvbmdl">https://gitee.com/kangyupl/sponge<i class="fa fa-external-link-alt"></i></span>  git clone 下来后直接切换分支就可以写。</p>
<p>编译 make<br>测试 make check_lab0</p>
<h1 id="lab0"><a href="#lab0" class="headerlink" title="lab0"></a>lab0</h1><p>中规中矩，热身实验。耗时1.5h左右。</p>
<p>实现 get_url函数,注意端口号部分写 http 代表服务类型就行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//! Construct by resolving a hostname and servicename. 函数重载采用这个函数</span></span><br><span class="line">    <span class="built_in">Address</span>(<span class="type">const</span> std::string &amp;hostname, <span class="type">const</span> std::string &amp;service);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    TCPSocket mysock;</span><br><span class="line">    mysock.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host,<span class="string">&quot;http&quot;</span>)); </span><br><span class="line"></span><br><span class="line">    mysock.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span>+path+<span class="string">&quot; HTTP/1.1\r\n&quot;</span>);</span><br><span class="line">    mysock.<span class="built_in">write</span>(<span class="string">&quot;Host: &quot;</span>+host+<span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mysock.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!mysock.<span class="built_in">eof</span>())&#123;<span class="comment">// eof代表读取完毕 且发送端也停止发送</span></span><br><span class="line">        <span class="keyword">auto</span> rec_message=mysock.<span class="built_in">read</span>();</span><br><span class="line">        cout&lt;&lt;rec_message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysock.<span class="built_in">closed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存中的通讯，采取了list的写法。注意下eof() 函数，头文件注意定义变量，别定义少了。</p>
<p>就是一个可以读取和写入的有序字节流，先写入的先被读取到。实现这个类的一些方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> _error&#123;&#125;;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br><span class="line">  std::list&lt;<span class="type">char</span>&gt; stream_content;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> capacity= <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> stream_size=<span class="number">0</span>;<span class="comment">// 最后一个写入的字节的序号，其实没用，当初写多了就一直保留了</span></span><br><span class="line">  <span class="type">bool</span> flag_finish=<span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> read_size=<span class="number">0</span>;<span class="comment">// 已经读取的长度</span></span><br><span class="line">  <span class="type">size_t</span> writen_size=<span class="number">0</span>;<span class="comment">// 已经写的长度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> mycapacity) : stream_content&#123;&#125;, <span class="built_in">capacity</span>(mycapacity), <span class="built_in">stream_size</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag_finish || _error) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> temp_size = writen_size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; temp : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((writen_size-read_size ) &gt;= capacity)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// list中的数据量满了 就退出</span></span><br><span class="line">        stream_size++;</span><br><span class="line">        writen_size++;</span><br><span class="line">        stream_content.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (writen_size - temp_size);<span class="comment">// 返回实际写入的数据长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_error) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">size_t</span> temp_len = <span class="number">0</span>;</span><br><span class="line">    <span class="function">string <span class="title">ans</span><span class="params">(len, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> temp_char : stream_content) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp_len == len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        temp_len++;</span><br><span class="line">        ans[temp_len - <span class="number">1</span>] = temp_char;<span class="comment">// 因为实际内容的长度可能不够 所以还需要一个 temp_len</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.<span class="built_in">substr</span>(<span class="number">0</span>, temp_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_error) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">size_t</span> cur_size=<span class="built_in">buffer_size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_size&lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// 防止数据量并没有len那么多 </span></span><br><span class="line">        cur_size--;</span><br><span class="line">        stream_content.<span class="built_in">pop_front</span>();</span><br><span class="line">        read_size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag_finish = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> flag_finish; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> writen_size-read_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> writen_size-read_size==<span class="number">0</span> ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">buffer_empty</span>() &amp;&amp; flag_finish;  <span class="comment">// 数据读取完毕 并且 输入端停止输入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writen_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> read_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> capacity - (writen_size-read_size); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><p>实现一个类，把无序可能重复到达的数据组合成有序的并且写入到_output中，_output就是lab0实现的Bytestream。耗时3.5h左右。</p>
<p>写之前可以先make测试一下，看看测试程序的样例，不然理解可能会有些偏差，我盯着样例看了一会才明白具体细节。</p>
<p>注意点如下</p>
<ol>
<li>到达数据会重叠</li>
<li>当到达数据全部被接受到（根据传入参数eof判断），且全部有序后，且全部写入output后，需要更新output的结束信号状态。</li>
<li>output的容量可能比StreamReassembler的小，不过这个lab中不用考虑这些…不知道为什么，考虑的话，当output的可用容量小于要写入的字节时候，你还要自己做个判断，并且定义一个新的变量。</li>
<li>按照道理，流重组器的数据写入顺序字节流后，流重组器的数据就可以删除了，不过这个lab没要求，我也懒得写，也不知道后面lab需不需要考虑。</li>
</ol>
<p>网上一个参考说明如下，不过这个lab其实并不用考虑</p>
<blockquote>
<p>LAB0的顺序字节流和LAB1的流重组器各有各的容量限制。流重组器把字节流写满后，只有当字节流腾出空后才能继续写，相当于字节流满时流重组器出口被“堵住”了。同样当流重组器容量满了后自身也无法被写入新数据，此时到来的新碎片只能被丢弃掉。</p>
</blockquote>
<p>选取合适数据结构很重要，写之前模拟半天，一个idea是两个链表，太复杂pass了，一个idea是双端队列+无序set，一个idea是string+无序set。</p>
<p>需要删除流重组器的数据的话用deque更好一些，不过我写的时候没考虑，直接用了string。 到时候看看再重构吧。</p>
<p>写完lab1 做lab2的时候我才知道</p>
<blockquote>
<p>lab1的担心是对的，确实需要删除已经写入有序字节流的元素，把lab2代码拉下来后重新测试发现lab1出错了，lab2新增了对lab1的测试，也就是测试有没有删掉已经写入顺序字节流的元素，所以fix bug采用了deque数据结构。</p>
</blockquote>
<p>以下是最新代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">  ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">  <span class="type">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line">  std::deque&lt;<span class="type">char</span>&gt; all_content_str;</span><br><span class="line">  std::unordered_set&lt;<span class="type">int</span>&gt; hash_str_unorderset=&#123;&#125;;</span><br><span class="line">  <span class="type">size_t</span> size_char_inorder=<span class="number">0</span>; <span class="comment">// 所有有序的数量，包括已经写入被pop出去的</span></span><br><span class="line">  <span class="type">size_t</span> size_char_all=<span class="number">0</span>; <span class="comment">//  // 所有数据的数量，包括已经写入被pop出去的</span></span><br><span class="line">  <span class="type">size_t</span> size_char_writen=<span class="number">0</span>;<span class="comment">// 写入到有序字节流中的数量</span></span><br><span class="line">  <span class="type">size_t</span> start_index=<span class="number">0</span>;<span class="comment">// deque中第一个字符的在字节流中的下标,其实和size_char_writen一样</span></span><br><span class="line">  <span class="type">bool</span> eof_flag=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">StreamReassembler::<span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity)</span><br><span class="line">    : _output(capacity), </span><br><span class="line">    _capacity(capacity), </span><br><span class="line">    <span class="built_in">all_content_str</span>(capacity, <span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \details This function accepts a substring (aka a segment) of bytes,</span></span><br><span class="line"><span class="comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span></span><br><span class="line"><span class="comment">//! contiguous substrings and writes them into the output stream in order.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> data_length = data.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> up_length = <span class="built_in">min</span>(data_length , _capacity+start_index-index); <span class="comment">// 实际可以写入的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; up_length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_str_unorderset.<span class="built_in">find</span>(i+index) == hash_str_unorderset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            hash_str_unorderset.<span class="built_in">emplace</span>(i+index);</span><br><span class="line">            all_content_str.<span class="built_in">at</span>(index-start_index+i) = data[i];</span><br><span class="line">            size_char_all++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 将收到的data写入缓冲区，同时更新hash表（hash表是判断对应序号的data是否被写入）</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = size_char_inorder-start_index; i &lt; _capacity; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_str_unorderset.<span class="built_in">find</span>(i+start_index) == hash_str_unorderset.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// hash中找不到，也就是该位置对应的data未被写入</span></span><br><span class="line"></span><br><span class="line">        size_char_inorder++;</span><br><span class="line">    &#125; <span class="comment">// 寻找连续序列（也就是重组好的序列），直到出现断层</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size_writable=<span class="built_in">min</span>(_output.<span class="built_in">remaining_capacity</span>(),size_char_inorder-size_char_writen);</span><br><span class="line">    <span class="comment">// 防止output内的缓冲长度不够，所以取最小值，同时还要定义一个size_char_written记录已经写入的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">temp</span><span class="params">(size_writable,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;size_writable;i++) temp[i]=all_content_str.<span class="built_in">at</span>(i);</span><br><span class="line"></span><br><span class="line">    _output.<span class="built_in">write</span>(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;size_writable;i++)&#123;</span><br><span class="line">        all_content_str.<span class="built_in">pop_front</span>();</span><br><span class="line">        all_content_str.<span class="built_in">emplace_back</span>(<span class="string">&#x27;0&#x27;</span>); <span class="comment">// pop后还要在deque尾部添加，保持容量不变。</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    size_char_writen+=size_writable; <span class="comment">// 更新写入的长度</span></span><br><span class="line">    start_index=size_char_writen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(eof) eof_flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(eof_flag &amp;&amp; <span class="keyword">this</span>-&gt;<span class="built_in">empty</span>())&#123;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;<span class="comment">// 接受到全部data后且全部写入到output后，output就可以更新结束信号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StreamReassembler::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="keyword">return</span> size_char_all - size_char_inorder; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size_char_all == size_char_inorder &amp;&amp; size_char_inorder==size_char_writen; &#125;</span><br><span class="line"><span class="comment">// 不仅全部要有序，所有的还必须被写入output ,可以直接写出 size_char_all==size_char_written</span></span><br></pre></td></tr></table></figure>


<h1 id="lab2-花费比较多，8h左右。"><a href="#lab2-花费比较多，8h左右。" class="headerlink" title="lab2  花费比较多，8h左右。"></a>lab2  花费比较多，8h左右。</h1><p>tcp receiver</p>
<h2 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h2><p>对我挺折磨的，主要是看不懂文档在说啥…，真正理解还是自己测试的时候，看测试代码才知道究竟让干啥，一些细节究竟是什么。</p>
<p>注释比较全面了，不过我的逻辑可能不太好理解，有问题可以给我提issue。</p>
<p>cout是debug时候看的，留着可能下个lab还要用，悲，测试样例不全就是这样的，不能相信之前自己写的lab。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> t_num = UINT32_MAX;</span><br><span class="line">    t_num++;</span><br><span class="line"></span><br><span class="line">    n = n % (t_num);  <span class="comment">// 先回退到第一个循环。</span></span><br><span class="line">    n += isn.<span class="built_in">raw_value</span>();</span><br><span class="line"></span><br><span class="line">    n = n % (t_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WrappingInt32</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n的绝对序列和checkpoint的差的绝对值一定小于(2^32)-1；</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; n  isn  check  &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; isn &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; checkpoint &lt;&lt; endl;</span><br><span class="line">    WrappingInt32 check_in_wrap32 = <span class="built_in">wrap</span>(checkpoint, isn);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; check in warp32 &quot;</span> &lt;&lt; check_in_wrap32 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">uint64_t</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> gap_1 = <span class="number">0</span>;  <span class="comment">// 记录n的绝对序列比checkpoint大的情况，当然我们并不知道究竟是大还是小，比较取得最合适的</span></span><br><span class="line">    <span class="type">uint64_t</span> gap_2 = <span class="number">0</span>;  <span class="comment">// 记录n的绝对序列比checkpoint小的情况</span></span><br><span class="line">    <span class="type">uint64_t</span> n_raw_value = n.<span class="built_in">raw_value</span>();</span><br><span class="line">    <span class="type">uint64_t</span> check_in_wrap32_raw_value = check_in_wrap32.<span class="built_in">raw_value</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gap均为正</span></span><br><span class="line">    <span class="comment">// 假设n的绝对序列比check大的情况，比check大的时候，有可能没有多一个循环，有可能多了一个循环</span></span><br><span class="line">    <span class="comment">// 比如 checkpoint的相对序列为 3，n的相对序列可能为1（此时n的绝对序列比 check大了 2^32-2） 也可能为 10，但每种情况</span></span><br><span class="line">    <span class="comment">// n的绝对序列都要比checkpoint大</span></span><br><span class="line">    <span class="keyword">if</span> (n_raw_value &lt; check_in_wrap32_raw_value) &#123;</span><br><span class="line">        gap_1 =</span><br><span class="line">            <span class="number">1</span> + n_raw_value + (<span class="type">uint64_t</span>)UINT32_MAX -</span><br><span class="line">            check_in_wrap32_raw_value;  <span class="comment">// 这里要加个一，因为跳入一个新的循环，要加1，想不通自己设个小点的数字，自己算一下</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        gap_1 = n_raw_value - check_in_wrap32_raw_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n_raw_value &gt; check_in_wrap32_raw_value) &#123;</span><br><span class="line">        gap_2 = <span class="number">1</span> + (<span class="type">uint64_t</span>)UINT32_MAX + check_in_wrap32_raw_value - n_raw_value;  <span class="comment">// 这里要加个一</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        gap_2 = check_in_wrap32_raw_value - n_raw_value;  <span class="comment">//  假设n的绝对序列比check小的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gap_1 &lt; gap_2) &#123;</span><br><span class="line">        ans = checkpoint + gap_1;</span><br><span class="line">    &#125;  <span class="comment">// 第一种情况更接近checkpoint</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (checkpoint &gt;= gap_2)</span><br><span class="line">        ans = checkpoint - gap_2;  <span class="comment">// 第二种情况更接近checkpoint</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = checkpoint + gap_1;  <span class="comment">// 虽然第二种情况更接近checkpoint，也就是n的绝对序列比checkpoint小，但是此时</span></span><br><span class="line">                                   <span class="comment">// checkpoint&lt;gap_2,相减会溢出(而 两者差距不可能那么大)，因此其实是第一种情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面三个if else 判断条件的 等号 要不要加 也要自己琢磨思考一下，不然会出错。</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h2><p>认真看文档，先理解让干啥再写，我漏看了后面的详细介绍，懵逼了半天，不知道从何下手，然后又看文档才发现后面有详细的介绍。</p>
<p>逻辑不难，本质上就是维护一个滑动窗口，然后确认什么时候接收数据，什么时候不接受。需要注意的是，这里的窗口大小被有序字节流和重组器的共同限制，这下知道我怎么发现lab0的bug了吧。需要注意的细节有点多，慢慢对着测试代码改吧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! Our data structure for re-assembling bytes.</span></span><br><span class="line">    StreamReassembler _reassembler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! The maximum number of bytes we&#x27;ll store.</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">    <span class="type">size_t</span> seg_length = <span class="number">0</span>;  <span class="comment">//// 当前TCPSegment的length</span></span><br><span class="line">    <span class="type">bool</span> seg_syn_flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> seg_fin_flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint64_t</span> checkpoint&#123;<span class="number">0</span>&#125;;  <span class="comment">// 检查号</span></span><br><span class="line">    <span class="type">uint32_t</span> offset_syn = <span class="number">0</span>;  <span class="comment">// 如果当前段是syn的话，因为需要转换stream index 所以需要＋1，syn是0 但是在stream</span></span><br><span class="line">                              <span class="comment">// index中不占位置，syn的下一位才是0</span></span><br><span class="line">                              </span><br><span class="line">    WrappingInt32 syn_num&#123;<span class="number">0</span>&#125;;  <span class="comment">// 整个字节流的初始序列号 也就是isn</span></span><br><span class="line">    WrappingInt32 seq_num&#123;<span class="number">0</span>&#125;;  <span class="comment">// 当前TCPSegment的序列号</span></span><br></pre></td></tr></table></figure>

<p>具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (seg_syn_flag)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// second SYN is rejected</span></span><br><span class="line">        offset_syn = <span class="number">1</span>;</span><br><span class="line">        seg_syn_flag = <span class="literal">true</span>;</span><br><span class="line">        syn_num = seg.<span class="built_in">header</span>().seqno;</span><br><span class="line">        checkpoint = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(<span class="number">0</span>);  <span class="comment">// 遇到syn的时候，设置初始序列号 和检查位,此时检查位应该为 0，因为此刻还没有开始转换，因此就选择0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!seg_syn_flag)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 没有开始的话就直接丢弃</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().fin &amp;&amp; seg_fin_flag)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// second FIN is rejected</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().fin)</span><br><span class="line">        seg_fin_flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    WrappingInt32 temp_seq_num&#123;seg.<span class="built_in">header</span>().seqno&#125;;</span><br><span class="line">    <span class="type">uint64_t</span> temp_cur_index = <span class="built_in">unwrap</span>(temp_seq_num + offset_syn, syn_num, checkpoint);  <span class="comment">// 该segment的绝对序列号</span></span><br><span class="line">    cout&lt;&lt; <span class="string">&quot; 收到的数据段的绝对序列号 &quot;</span>&lt;&lt;temp_cur_index&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//_reassembler.ack_n()+1 期望收到的下一个数据的绝对序列号</span></span><br><span class="line">    <span class="keyword">if</span> (_reassembler.<span class="built_in">ack_n</span>() + <span class="number">1</span> + _reassembler.<span class="built_in">empty_length</span>() &lt;= temp_cur_index)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 当前段的序列超过窗口范围 丢弃</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; 当前段的序列超过窗口范围 丢弃 &quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    seg_length = seg.<span class="built_in">length_in_sequence_space</span>()-seg.<span class="built_in">header</span>().syn-seg.<span class="built_in">header</span>().fin;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(seg_length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">wrap</span>(temp_cur_index, syn_num)-<span class="built_in">wrap</span>(_reassembler.<span class="built_in">ack_n</span>() + <span class="number">1</span>, syn_num) &lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="comment">// 重复空报文</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">wrap</span>(temp_cur_index, syn_num) + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(seg_length<span class="number">-1</span>+seg.<span class="built_in">header</span>().fin)</span><br><span class="line">            -<span class="built_in">wrap</span>(_reassembler.<span class="built_in">ack_n</span>() + <span class="number">1</span>, syn_num) &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; 判断接受到的 重叠且这个数据段没有新的信息 直接丢弃 &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 判断接受到的 重叠且这个数据段没有新的信息 直接丢弃，fin报文也算数据 因此也要计算</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    seq_num = seg.<span class="built_in">header</span>().seqno;</span><br><span class="line">    <span class="type">uint64_t</span> cur_index = <span class="built_in">unwrap</span>(seq_num + offset_syn, syn_num, checkpoint);  </span><br><span class="line">        <span class="comment">// 绝对序列号,syn不占流里面的下标位置 因此有syn的时候 算的是syn之后一位的位置。</span></span><br><span class="line"></span><br><span class="line">    checkpoint = cur_index + seg_length - <span class="number">1</span>;  <span class="comment">// 最近确认的绝对序列号</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; 进入重组 &quot;</span>&lt;&lt;cur_index&lt;&lt;endl;</span><br><span class="line">    _reassembler.<span class="built_in">push_substring</span>(seg.<span class="built_in">payload</span>().<span class="built_in">copy</span>(), cur_index - <span class="number">1</span>, seg_fin_flag);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    offset_syn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (seg_syn_flag == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">    <span class="type">uint64_t</span> n = _reassembler.<span class="built_in">ack_n</span>() + <span class="number">1</span>;  <span class="comment">// 期望收到的绝对序列号，ack_n返回的是stream_index</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; 期望收到的绝对序列号n &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">wrap</span>(n, syn_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _reassembler.<span class="built_in">empty_length</span>(); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在lab1中的流重组器中加了两个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//   可以被写入的数据长度,也就是有序字节流中还剩下的空间 和 重组器中剩下的空间减去已经有序但还未进入重组器的长度  的较小值。</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">empty_length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回下一个期望收到的字符的stream index</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">ack_n</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">StreamReassembler::ack_n</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eof_flag)</span><br><span class="line">        <span class="keyword">return</span> size_char_inorder + <span class="number">1</span>;<span class="comment">// ＋1是因为fin也被看做一个字节 但是不会被写进去</span></span><br><span class="line">    <span class="keyword">return</span> size_char_inorder;  <span class="comment">// 返回下一个期望收到的字符的stream index</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">StreamReassembler::empty_length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(_output.<span class="built_in">remaining_capacity</span>()-(size_char_inorder-size_char_writen), _capacity - (size_char_inorder - size_char_writen));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中期总结"><a href="#中期总结" class="headerlink" title="中期总结"></a>中期总结</h1><p>lab0实现了内存中的顺序读取结构，也就是bytestream。</p>
<p>lab1在此基础上实现了重组器，把不按照顺序到达的数据重新组装起来，流重组器控制传入数据读取多少，需要读取哪些数据，下一个需要读取的数据序号（ack的序号）。</p>
<p>lab2在两者基础上维护了一个滑动窗口，根据窗口大小，还有数据的序号关系，各种特殊情况怎么处理，选择是否接受数据，把数据传入流重组器（数据接收并不一定被全部接收，可能被流重组器部分接收，不过这不需要管，只要有数据需要被接收就传入流重组器，receiver不需要考虑接收多少，这是流重组器需要处理的）。</p>
<h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><p>实现tcp sender</p>
<p>根据远方接收者的窗口内可接收新数据的长度 以及  我们可以发送的数据长度 发送tcp segment给receiver。<br>我们要发送的数据都在bytestream里面，也就是有序字节流中。</p>
<p>当然也要实现最开始发送syn空报文，结束发送fin报文的功能。</p>
<p>重传机制：设置重传计时器和超时时间，收到新的报文ack就重新启动重传计时器和超时时间，超时就需要重传最小的未被确认的报文。</p>
<p>未被确认的报文都需要进行缓存，确认后再pop出去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//! our initial sequence number, the number for our SYN.</span></span><br><span class="line">  WrappingInt32 _isn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! outbound queue of segments that the TCPSender wants sent，这个队列我们并不能控制 </span></span><br><span class="line">  std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 等待被确认的，因为可能需要重传 所以需要缓存下，</span></span><br><span class="line">  std::queue&lt;TCPSegment&gt; _segments_wait&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! retransmission timer for the connection  rto的初始值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> _initial_retransmission_timeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! outgoing stream of bytes that have not yet been sent</span></span><br><span class="line">  ByteStream _stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! the (absolute) sequence number for the next byte to be sent</span></span><br><span class="line">  <span class="type">uint64_t</span> _next_seqno&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> syn_sent=<span class="literal">false</span>;<span class="comment">// 是否发送最开始的syn</span></span><br><span class="line">  <span class="type">bool</span> fin_sent=<span class="literal">false</span>;<span class="comment">// 是否发送结束的fin</span></span><br><span class="line">  <span class="type">size_t</span> remote_window_size=<span class="number">1</span>;<span class="comment">// 远方接收者的窗口，限制了我们发送数据的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> cur_all_time=<span class="number">0</span>;<span class="comment">// 当前已经过去的时间</span></span><br><span class="line">  <span class="type">size_t</span> next_retran_time=<span class="number">0</span>;<span class="comment">// 下次需要重传的时间，也就是说 调用tick时候 假如当前时间超过了next_retran_time 就代表超时</span></span><br><span class="line">  <span class="type">bool</span> tcp_timer_running=<span class="literal">false</span>; <span class="comment">// 计时器是否正在运行</span></span><br><span class="line">  <span class="type">size_t</span> cur_rto=<span class="number">0</span>;<span class="comment">// 当前的rto</span></span><br><span class="line">  <span class="type">size_t</span> continuous_retran_num=<span class="number">0</span>;<span class="comment">// 连续重传的数量</span></span><br><span class="line">  <span class="type">uint64_t</span> cur_bytes_length_in_flight=<span class="number">0</span>;<span class="comment">// 未被确认的序列号长度 syn和fin也算一个长度&#x27;</span></span><br></pre></td></tr></table></figure>

<p>具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">TCPSender::<span class="built_in">TCPSender</span>(<span class="type">const</span> <span class="type">size_t</span> capacity, <span class="type">const</span> <span class="type">uint16_t</span> retx_timeout, <span class="type">const</span> std::optional&lt;WrappingInt32&gt; fixed_isn)</span><br><span class="line">    : _isn(fixed_isn.<span class="built_in">value_or</span>(WrappingInt32&#123;<span class="built_in">random_device</span>()()&#125;))</span><br><span class="line">    , _initial_retransmission_timeout&#123;retx_timeout&#125;</span><br><span class="line">    , _stream(capacity)</span><br><span class="line">    , syn_sent&#123;<span class="literal">false</span>&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cur_bytes_length_in_flight; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fin_sent) <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (syn_sent == <span class="literal">false</span>) &#123;</span><br><span class="line">        TCPSegment syn_seg;</span><br><span class="line">        syn_seg.<span class="built_in">header</span>().syn = <span class="literal">true</span>;</span><br><span class="line">        syn_seg.<span class="built_in">header</span>().seqno = _isn;</span><br><span class="line">        _next_seqno=<span class="number">1</span>;  <span class="comment">// 因为最开始的syn报文长度为1，所以＋1就ok了</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(syn_seg);</span><br><span class="line">        _segments_wait.<span class="built_in">push</span>(syn_seg);</span><br><span class="line">        syn_sent = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp_timer_running==<span class="literal">false</span>) &#123;</span><br><span class="line">            tcp_timer_running = <span class="literal">true</span>;</span><br><span class="line">            cur_rto = _initial_retransmission_timeout;</span><br><span class="line">            next_retran_time = cur_all_time + cur_rto;</span><br><span class="line">            continuous_retran_num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur_bytes_length_in_flight = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(syn_seg.<span class="built_in">length_in_sequence_space</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> cur_send_size = <span class="built_in">min</span>(_stream.<span class="built_in">buffer_size</span>(), (remote_window_size - <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(cur_bytes_length_in_flight)));</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> temp_i = <span class="number">1450</span>;  <span class="comment">// 用temp_i 主要是为了使用min函数 不然类型不匹配</span></span><br><span class="line">    <span class="type">size_t</span> seg_num = cur_send_size / temp_i;</span><br><span class="line">    <span class="type">size_t</span> end_length=cur_send_size-seg_num*temp_i;</span><br><span class="line">    <span class="keyword">if</span> (cur_send_size &gt; <span class="number">0</span>)</span><br><span class="line">        seg_num++;<span class="comment">// 当前能够发送的报文数量</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 发送fin报文</span></span><br><span class="line">    <span class="keyword">if</span>(cur_bytes_length_in_flight&lt;remote_window_size &amp;&amp; _stream.<span class="built_in">eof</span>())&#123;<span class="comment">// 结束输入 并且要保证接收窗口有位置接受fin报文</span></span><br><span class="line">        fin_sent = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        TCPSegment fin_seg;</span><br><span class="line">        fin_seg.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">        fin_seg.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line">        _next_seqno += <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(fin_seg.<span class="built_in">length_in_sequence_space</span>());</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(fin_seg);</span><br><span class="line">        _segments_wait.<span class="built_in">push</span>(fin_seg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp_timer_running==<span class="literal">false</span>) &#123;</span><br><span class="line">            tcp_timer_running = <span class="literal">true</span>;</span><br><span class="line">            cur_rto = _initial_retransmission_timeout;</span><br><span class="line">            next_retran_time = cur_all_time + cur_rto;</span><br><span class="line">            continuous_retran_num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        cur_bytes_length_in_flight += <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(fin_seg.<span class="built_in">length_in_sequence_space</span>());</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; seg_num; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp_timer_running == <span class="literal">false</span>) &#123;</span><br><span class="line">            tcp_timer_running = <span class="literal">true</span>;</span><br><span class="line">            cur_rto = _initial_retransmission_timeout;</span><br><span class="line">            next_retran_time = cur_all_time + cur_rto;</span><br><span class="line">            continuous_retran_num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string temp_seg_content;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==seg_num<span class="number">-1</span>) temp_seg_content = _stream.<span class="built_in">peek_output</span>(end_length);</span><br><span class="line">        <span class="keyword">else</span> temp_seg_content = _stream.<span class="built_in">peek_output</span>(temp_i);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        _stream.<span class="built_in">pop_output</span>(<span class="built_in">min</span>(temp_i, cur_send_size));  <span class="comment">// 用temp_i 主要是为了使用min函数 不然类型不匹配</span></span><br><span class="line">        TCPSegment cur_seg;</span><br><span class="line"></span><br><span class="line">        cur_seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(std::<span class="built_in">move</span>(temp_seg_content));  <span class="comment">// 发送的segment的内容</span></span><br><span class="line">        cur_seg.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);         <span class="comment">// 绝对序列号转换为相对序列号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == seg_num - <span class="number">1</span> &amp;&amp; _stream.<span class="built_in">eof</span>())</span><br><span class="line">            cur_seg.<span class="built_in">header</span>().fin = <span class="literal">true</span>;  <span class="comment">// 判断是否结束 fin标志位设置，只有最后输出的时候可能是fin报文</span></span><br><span class="line"></span><br><span class="line">        _next_seqno += <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(cur_seg.<span class="built_in">length_in_sequence_space</span>());  <span class="comment">// 绝对序列号增加</span></span><br><span class="line"></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(cur_seg);</span><br><span class="line">        _segments_wait.<span class="built_in">push</span>(cur_seg);</span><br><span class="line"></span><br><span class="line">        cur_bytes_length_in_flight += <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(cur_seg.<span class="built_in">length_in_sequence_space</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"><span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"><span class="comment">//! \returns `false` if the ackno appears invalid (acknowledges something the TCPSender hasn&#x27;t sent yet)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ackno, <span class="type">const</span> <span class="type">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ackno - <span class="built_in">next_seqno</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 确认的是还没有发送的数据，说明出错了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> old_rece_free_length = remote_window_size - <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(cur_bytes_length_in_flight);</span><br><span class="line">    <span class="comment">// 我们认为的远方接收者的 可以接收我们发送的新数据的剩余空间（旧的数据远方接收者收到但未给我们确认的话，这是重传机制需要搞定的事情，这里不需要管）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!_segments_wait.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (_segments_wait.<span class="built_in">front</span>().<span class="built_in">header</span>().seqno - ackno &lt; <span class="number">0</span>) &#123;  <span class="comment">// 按照道理这里还应该加上数据长度，但tcp的segment不可能被分开（可能吗，我现在感觉不可能），所以不加也没问题吧</span></span><br><span class="line"></span><br><span class="line">            cur_rto = _initial_retransmission_timeout;</span><br><span class="line">            continuous_retran_num = <span class="number">0</span>;</span><br><span class="line">            tcp_timer_running = <span class="literal">true</span>;</span><br><span class="line">            next_retran_time = cur_all_time + cur_rto;</span><br><span class="line">            <span class="comment">// 不为空就重启定时器，设置好重传时间 rto 重传次数</span></span><br><span class="line"></span><br><span class="line">            cur_bytes_length_in_flight -= <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(_segments_wait.<span class="built_in">front</span>().<span class="built_in">length_in_sequence_space</span>());</span><br><span class="line"></span><br><span class="line">            _segments_wait.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;  <span class="comment">// 移除已经被确认的 segment</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_segments_wait.<span class="built_in">empty</span>())  tcp_timer_running = <span class="literal">false</span>;  <span class="comment">// 全部确认 计时器关闭</span></span><br><span class="line"></span><br><span class="line">    remote_window_size = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(window_size);  <span class="comment">// 更新窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> cur_rece_free_length=remote_window_size-<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(cur_bytes_length_in_flight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_rece_free_length&gt;old_rece_free_length &amp;&amp; _stream.<span class="built_in">buffer_size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fill_window</span>();</span><br><span class="line">    &#125;  <span class="comment">// rece有空间可以接收 且 有数据可以发送 就继续发送</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    cur_all_time += ms_since_last_tick;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mytcp_timer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::mytcp_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tcp_timer_running == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 实际上tick和计时器是两个东西 tick是用来获取时间的 计时器是计时器</span></span><br><span class="line">                 <span class="comment">// 不过计时器基于tick，因此写在tick里面也ok。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_all_time &gt;= next_retran_time &amp;&amp; !_segments_wait.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(_segments_wait.<span class="built_in">front</span>());</span><br><span class="line">        continuous_retran_num++;</span><br><span class="line">        cur_rto *= <span class="number">2</span>;</span><br><span class="line">        next_retran_time = cur_all_time + cur_rto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> continuous_retran_num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment cur_seg;</span><br><span class="line">    cur_seg.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);  <span class="comment">// 绝对序列号转换为相对序列号</span></span><br><span class="line">    _segments_out.<span class="built_in">push</span>(cur_seg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span>&amp; <span class="title">TCPSender::sender_syn_sent</span>  <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syn_sent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h1><p>tcp connection </p>
<p>把前面的4个lab内容结合起来，实现一个完整的tcp自动机。</p>
<p>需要处理的细节很多很多很多…….</p>
<p>主要就四个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">()</span></span>; <span class="comment">// 初始连接 发送syn报文</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;data)</span></span>; <span class="comment">// 把需要被发送的数据写入有序字节流等待被发送 同时让sender类发送这些数据（假如根据窗口大小判断 能发送的话）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span></span>;<span class="comment">// 这个函数由操作系统调用，获取过去的时间，超时就进行重传操作，重传次数太多会发送rst报文结束连接。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span></span>; <span class="comment">// 接收到了新的报文 就调用receiver更新信息，同时调用sender发送ack报文和数据。同时也要处理一些异常情况</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> cur_time_since_last_segment_received;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(!_sender.<span class="built_in">sender_syn_sent</span>() &amp;&amp; !seg.<span class="built_in">header</span>().syn &amp;&amp; !recv_start) <span class="keyword">return</span>; <span class="comment">// 如果我们没发送syn 对面发送的这个数据也不是syn 并且也没有启动（没这个标记的话 对面发送syn 之后的数据就没法接收了） 那就拒绝接收数据</span></span><br><span class="line">    recv_start=<span class="literal">true</span>;<span class="comment">// 开始启动</span></span><br><span class="line">    <span class="keyword">if</span>(rst_receved) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(seg.<span class="built_in">header</span>().rst)&#123;</span><br><span class="line">        _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        _linger_after_streams_finish=<span class="literal">false</span>;</span><br><span class="line">        rst_receved=<span class="literal">true</span>;</span><br><span class="line">        active_tcp=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur_time_since_last_segment_received=<span class="number">0</span>;<span class="comment">// 重设间隔时间</span></span><br><span class="line"></span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win); <span class="comment">// 数据传输给接收类，发送类发送对应数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; !_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        <span class="comment">// 如果入站流在TCPConnection到达其出站流的EOF之前结束，则需要将此变量设置为false</span></span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 被动关闭 对面fin之后 我们发送ack 然后接收类就处理数据发送完毕后 会发送fin给对方 后半部分的逻辑和主动关闭差不多</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;<span class="comment">// 没有数据可以发送时候 收到了数据包 可能是三次握手的syn 四次挥手的fin 和 ack，这时候发送类不会不会产生包来发送</span></span><br><span class="line">        <span class="comment">//需要产生一个空段进行ack</span></span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; !seg.<span class="built_in">header</span>().fin) &#123;</span><br><span class="line">            <span class="comment">// 已经关闭了 被动或者主动关闭 这时候收到不是fin的包就不产生空包回应</span></span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*else if(seg.length_in_sequence_space() == 0 &amp;&amp; </span></span><br><span class="line"><span class="comment">        _sender.next_seqno_absolute() &gt; _sender.bytes_in_flight() </span></span><br><span class="line"><span class="comment">        &amp;&amp; !_sender.stream_in().eof())&#123;</span></span><br><span class="line"><span class="comment">            // 连接已经建立时候 需要回复空包</span></span><br><span class="line"><span class="comment">            _sender.send_empty_segment(); // 发送空包进行ack</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="comment">//  连接未建立时候就不发送空包回复</span></span><br><span class="line">            <span class="comment">// 不直接return是因为 可能是有其他数据需要发送</span></span><br><span class="line">           <span class="comment">// cout&lt;&lt;&quot; 没有建立连接的时候就不发送空包回复 &quot;&lt;&lt;endl;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// cout&lt;&lt;&quot; 发送空包 &quot;&lt;&lt;endl;</span></span><br><span class="line">            _sender.<span class="built_in">send_empty_segment</span>(); <span class="comment">// 发送空包进行ack</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; (cur_time_since_last_segment_received &gt;= _cfg.rt_timeout * <span class="number">10</span> || _linger_after_streams_finish==<span class="literal">false</span>)) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 数据全部接收处理 发送 被确认 结束 且 time_wait时间结束(或者是被动关闭 不需要time_wait)</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (rst_receved || !active_tcp) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> writen_num=_sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">    <span class="keyword">return</span> writen_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123; </span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    cur_time_since_last_segment_received+=ms_since_last_tick;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot; 间隔时间 &quot;&lt;&lt;cur_time_since_last_segment_received&lt;&lt;&quot; &quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">send_segments</span>();<span class="comment">// 时间流逝后 发送类可能会有新的数据需要发送 因此需要send_segments()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_time_wait &amp;&amp; cur_time_since_last_segment_received &gt;= _cfg.rt_timeout * <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot; 关闭连接 &quot;&lt;&lt;endl;</span></span><br><span class="line">        _time_wait = <span class="literal">false</span>;</span><br><span class="line">        recv_start=<span class="literal">false</span>;</span><br><span class="line">        active_tcp=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; _cfg.MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">        <span class="comment">// 重传次数太多 就进入rst状态</span></span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// pop出数据</span></span><br><span class="line">            _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">        TCPSegment&amp; seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        seg.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">        active_tcp=<span class="literal">false</span>;</span><br><span class="line">        rst_receved=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">send_segments</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>(); <span class="comment">//结束输出流，因此先关闭有序字节的写端</span></span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();<span class="comment">// 然后输出剩余的所有 未被发送的 数据</span></span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_sender.<span class="built_in">sender_syn_sent</span>())&#123;</span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        TCPSegment&amp; syn_seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        syn_seg.<span class="built_in">header</span>().win = <span class="built_in">min</span>(_receiver.<span class="built_in">window_size</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(UINT16_MAX));<span class="comment">// uint16_t win = 0;  window size ,防止传递窗口过大</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(syn_seg);</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_segments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!active_tcp || rst_receved) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment&amp; seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">            <span class="comment">//cout&lt;&lt; &quot; 发送报文 设置ack &quot;&lt;&lt;seg.header().ackno&lt;&lt;endl;</span></span><br><span class="line">        &#125;<span class="comment">// 设置ack</span></span><br><span class="line">        seg.<span class="built_in">header</span>().win = <span class="built_in">min</span>(_receiver.<span class="built_in">window_size</span>(),<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(UINT16_MAX));</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//if(seg.header().fin) cout&lt;&lt;&quot; 发送了fin 报文 &quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_linger_after_streams_finish) &#123;<span class="comment">// 接收类接收完毕 发送类发送完毕且发送的包也全部被确认 那就主动关闭</span></span><br><span class="line">            _time_wait = <span class="literal">true</span>;</span><br><span class="line">           <span class="comment">// cout&lt;&lt;&quot; 进入time_wait &quot;&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">            <span class="comment">//cerr &lt;&lt; &quot;Warning: Unclean shutdown of TCPConnection\n&quot;;</span></span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            rst_receved=<span class="literal">true</span>;</span><br><span class="line">            active_tcp=<span class="literal">false</span>;</span><br><span class="line">            _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="comment">// pop all segments</span></span><br><span class="line">                _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">            TCPSegment&amp; seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">            seg.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">send_segments</span>();</span><br><span class="line">            <span class="comment">// Your code here: need to send a RST segment to the peer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; &quot;Exception destructing TCP FSM: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>用官方提供的sponge&#x2F;libsponge&#x2F;util&#x2F;buffer.cc中的 BufferList类来作为ByteStream的容器，使得原来基于内存拷贝的存储方法变为基于内存所有权转移。</p>
<p>用c++的 std::move assign 右值引用等新特性对 ByteStream进行改造。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/17/%E7%B9%81%E5%BF%99%E7%9A%8423%E5%B9%B4%E4%B8%8A%E5%8D%8A%E5%B9%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="FY-Zhu">
      <meta itemprop="description" content="见山还是山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="源之居">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/17/%E7%B9%81%E5%BF%99%E7%9A%8423%E5%B9%B4%E4%B8%8A%E5%8D%8A%E5%B9%B4/" class="post-title-link" itemprop="url">繁忙的23年上半年</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-17 17:57:31 / 修改时间：18:07:01" itemprop="dateCreated datePublished" datetime="2023-04-17T17:57:31+08:00">2023-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="忙"><a href="#忙" class="headerlink" title="忙"></a>忙</h1><p>今天周一，课表上也只有两次一共4小节课程，按道理来说今天并没有多么忙，只是，生活不讲道理。</p>
<p>七点多起来之后，迷迷糊糊上完热统早八，十点多回到宿舍，写完三道算法题后已经将近十二点，吃完饭回来简单整理了一下思路，回复了一些必要的消息+看了看今日to do后又到了计算物理的签到时间。索性翘掉了课程，网上扫码签到一气呵成，然后午睡。</p>
<p>入睡很快，只是做的梦显得我压力很大的样子，梦中大概是又多了一些dll，整个人有些烦闷，睡觉过程中能感觉到自己有几个翻身的大动作。<br>醒来后查看消息，确实，又多了个ddl。</p>
<p>原子物理刚好出分，平均分略高，虽不如热统期中分数那么高，但也还可以，毕竟考试时候看见题目的我过于懵逼，一时间不知道自己是在学原子物理还是在学数学分析，怎么那么多定理证明题啊。</p>
<p>忙，会有结果的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/10/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="FY-Zhu">
      <meta itemprop="description" content="见山还是山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="源之居">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/10/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">链接的一些事情</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-10 17:21:22" itemprop="dateCreated datePublished" datetime="2023-04-10T17:21:22+08:00">2023-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-19 20:33:00" itemprop="dateModified" datetime="2023-05-19T20:33:00+08:00">2023-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在学习初期就对与头文件和链接有些迷茫，今天简单谈谈这些事情。</p>
<h1 id="从源代码到可执行文件"><a href="#从源代码到可执行文件" class="headerlink" title="从源代码到可执行文件"></a>从源代码到可执行文件</h1><p>使用g++&#x2F;gcc 工作流程如下<br><a target="_blank" rel="noopener" href="https://imgloc.com/i/imhe9P"><img src="https://i.328888.xyz/2023/04/10/imhe9P.png" alt="流程图.png"></a></p>
<p>预处理：宏的展开，头文件展开，条件编译，去除注释等操作。</p>
<p>编译和汇编就不再叙述</p>
<p>链接：将目标代码中用到的所有相关的代码链接在一起，比如各种库函数和自己定义的各种函数。</p>
<h1 id="预处理和链接"><a href="#预处理和链接" class="headerlink" title="预处理和链接"></a>预处理和链接</h1><p>初学的时候，我迷惑的点在于，既然预处理已经展开头文件，那么链接又在链接什么？直到自己完成了lept_json这个完整的项目之后，才对这个问题有了更加清晰的认识。</p>
<p>首先了解一下gcc&#x2F;g++ 的用法<br><a target="_blank" rel="noopener" href="https://www.picgo.net/image/zTz2K"><img src="https://img.picgo.net/2023/05/19/image56afcdcda47539c8.md.png" alt="image56afcdcda47539c8.md.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://www.picgo.net/image/zTwoA"><img src="https://img.picgo.net/2023/05/19/image9eade6b095c77371.md.png" alt="image9eade6b095c77371.md.png"></a></p>
<blockquote>
<blockquote>
<p>-o 也可以用来指定生成的文件的名称，否则会为默认文件名。 </p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">---test.cpp---</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head_file1.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> t1=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fun</span>(t1);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;this is test&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---head_file1.h---</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> t1)</span></span>;</span><br><span class="line"></span><br><span class="line">---head_file1.cpp---</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> t1)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;t1&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>g++生成可执行文件的命令如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -c test.cpp -o test.o</span><br><span class="line">g++ -c head_file1.cpp -o head_file1.o</span><br><span class="line">g++ test.o head_file1.o -o test</span><br></pre></td></tr></table></figure>

<p>或者直接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp head_file1.cpp -o test <span class="comment">// 文件的先后顺序不影响正确性</span></span><br></pre></td></tr></table></figure>

<p>在实际开发过程中，良好的习惯是将函数的声明和定义分开，声明写在 xxx.h，定义写在 xxx.cpp。例子中 fun() 的定义和声明就是分开的</p>
<p>预处理就是将头文件展开，也就是将head_file1.h 中的 fun函数声明 在 test.cpp 中展开。</p>
<p>预处理过后 test.cpp中有了fun函数的声明，在接下来的编译过程中，它是符合规范的，即便现在编译器并不知道fun函数的定义。</p>
<p>链接过程中，链接器看到fun函数的声明，会去找fun函数的定义，那么怎么找到fun函数的定义呢？</p>
<p>我们将fun函数定义在了 head_file1.cpp中，因此就需要将 head_file1.cpp的目标代码(head_file1.o) 和test.cpp的目标代码(test.o) 链接起来生成 可执行文件</p>
<p>在第一种方法中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -c test.cpp -o test.o <span class="comment">// 生成目标代码 test.o  该文件中含有fun函数的声明但并没有定义</span></span><br><span class="line">g++ -c head_file1.cpp -o head_file1.o <span class="comment">// 生成目标代码 head_file.o</span></span><br><span class="line">g++ test.o head_file1.o -o test <span class="comment">// 两个文件链接在一起，此时就有了fun函数的具体实现</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp head_file1.cpp -o test <span class="comment">// 两个文件一起处理，作用和第一种方法是一致的</span></span><br></pre></td></tr></table></figure>

<h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>也许有人会想着先处理头文件对应的head_file1.cpp 然后处理 test.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ head_file1.cpp  -o test </span><br></pre></td></tr></table></figure>

<p>这样是错误的，因为head_file1.cpp 中并没有main()函数，因此链接会出现错误，所以我们只能生成目标代码，也就是使用 -c 这个命令，停留在链接之前，然后和test.o 一起链接处理，test.o中是有main()函数的哦。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>linux中文件的后缀其实并没用，我们只是习惯 .o .s .cpp 这些；</p>
<p>head_file1.cpp 并不一定要和 head_file1.h 的名字一样，只是这样更加规范一些，g++是不会在乎这些名字的，因为 .h文件 是在预处理阶段展开的， 对应的 .cpp 文件是在链接阶段和test.o 链接在一起的，链接器并不是根据名字找到头文件对应的.cpp后缀的源代码的(当然，链接时候已经变成了 .o 后缀的目标代码)。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>三个文件都引用了标准库，但并没有重复定义的问题，为什么？</p>
<h3 id="第一，我们可以使用"><a href="#第一，我们可以使用" class="headerlink" title="第一，我们可以使用"></a>第一，我们可以使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件编译</span></span><br><span class="line">     <span class="meta">#<span class="keyword">define</span>        <span class="comment">//  宏定义 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">undef</span>         <span class="comment">//  取消宏 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">include</span>       <span class="comment">//  文本包含 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">ifdef</span>         <span class="comment">//  如果宏被定义就进行编译 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">if</span> defined    <span class="comment">//  与ifdefine的区别在于可以可以组成复杂的判别条件</span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">ifndef</span>        <span class="comment">//  如果宏未被定义就进行编译 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">if</span> !defined   <span class="comment">//  与if !define的区别在于可以可以组成复杂的判别条件</span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">endif</span>         <span class="comment">//  结束编译块的控制 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">if</span>   defined        <span class="comment">//  表达式非零就对代码进行编译 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">else</span>          <span class="comment">//  作为其他预处理的剩余选项进行编译 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">elif</span>          <span class="comment">//  这是一种#else和#if的组合选项 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">elif</span> defined    <span class="comment">//  与ifdefine的区别在于可以可以组成复杂的判别条件</span></span></span><br><span class="line">	 <span class="meta">#<span class="keyword">elif</span> !defined    <span class="comment">//  与ifdefine的区别在于可以可以组成复杂的判别条件</span></span></span><br><span class="line"><span class="comment">//编译指令</span></span><br><span class="line">     <span class="meta">#<span class="keyword">line</span>          <span class="comment">//  改变当前的行数和文件名称 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">error</span>         <span class="comment">//  输出一个错误信息 </span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">pragma</span>        <span class="comment">//  为编译程序提供非常规的控制流信息，可跟once，message等许多参数。</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>标准库中都含有条件编译指令<br>这些指令来避免重复定义(也能避免重复声明，但是重复声明只是会增加代码体积而已)，但是请注意条件编译指令是在<strong>预处理阶段</strong>进行的，也就是说</p>
<blockquote>
<blockquote>
<p>这里针对的都是在一个.cpp文件中避免头文件重复引入。如果一个工程有多个”.cpp”文件，由于编译器对每个.cpp文件是分开处理的，只在最后进行链接。在这种情况下，如果有多个.c文件都直接或间接引入了某个头文件，这时无法避开的。</p>
</blockquote>
</blockquote>
<p>我们的 head_file1.h 和 test.cpp 都引用库函数，但是在预处理阶段就已经处理掉了，只会引用一次。但是这两个文件(test.cpp head_file1.cpp)都有标准库啊，链接时候怎么没出错呢？</p>
<p>这就是定义和声明分开的好处，我们引用的头文件是标准库各种函数的声明，而不是定义，而重复声明并没关系(当然为了节省代码体积，减少内存开销，最好能不用头文件就不用，不要一股脑把可能用到的库函数头文件全部写上)，在链接的时候，库函数对应的 .o 文件会和我们的目标代码链接, 链接器虽然看到了那么多头文件库函数声明，但是对应的 库函数 .o 代码，链接器只会链接一次，避免出现重复定义错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">---test.cpp---</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head_file1.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> t1=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fun</span>(t1);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;this is test&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---head_file1.h---</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> t1)</span></span>; <span class="comment">// 头文件可以全部删掉，并没有用到，即便不删，预处理阶段也会被忽略掉</span></span><br><span class="line"></span><br><span class="line">---head_file1.cpp---</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> t1)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;t1&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/21/2022/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="FY-Zhu">
      <meta itemprop="description" content="见山还是山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="源之居">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/21/2022/" class="post-title-link" itemprop="url">如梦一般的2022</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-21 23:31:08" itemprop="dateCreated datePublished" datetime="2023-01-21T23:31:08+08:00">2023-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-30 13:57:24" itemprop="dateModified" datetime="2023-09-30T13:57:24+08:00">2023-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天是除夕，再过几十分钟就到了新年的第一天，除旧迎新不外乎如此。</p>
<p>回想过去的一年，前半年的斗志昂扬，刚过完生日时内心的踌躇满志，再次被隔离时的颓废，面对大变向的疑惑，破碎的经历造就了梦幻的2022。</p>
<p>专业课的学习有种一地鸡毛的感觉，大概是不适应老师的缘故，所幸我从课本上还是学到了一些东西，只是有种根基不牢固的惶恐。在大二上学期，我通过了经济学的辅修，辅修经济学一方面是想对社会运转体系有更深刻的了解；另一方面是出于走一步闲棋，多一条路的想法。CS方面在20岁生日后没有什么太大的进展，只是会写一些算法题，demo没有做，书也没有看，荒废的令我感到不安。</p>
<p>学业荒废的主要原因是我的心态出了问题。22年暑假结束返校后刚开学又再次被封控，中间上了几周课后又再次被封控。网课、网课、网课,摆烂、摆烂、摆烂，在狭窄的宿舍内通过屏幕看老师讲授混乱的知识，debuff太多了，我的学习状态不受控制的在糟糕的课程质量和封控压力下趋向于摆烂。下半年的时光说是虚度也没错。</p>
<p>零点到了，你要新年快乐呀。</p>
<p>2022想看的书也没有看完，只能留给2023的我看了，希望他可以认真读完我想看的书，相信后人（我）的智慧！</p>
<p>想去的地方因为疫情也没有去，同样相信未来的我会去看的！</p>
<p>没有什么好写的了，下半年对我来说是有点糟糕的，没有什么可以记录的。</p>
<p>未来会怎样呢？我不知道，不过怕什么？干就完事了。</p>
<p>2023，要去实习，要充实自己的知识，要身体健康，要开心。</p>
<p>旧的一年过去了，崭新的一年在键盘声中开始了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/19/20YearsOld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="FY-Zhu">
      <meta itemprop="description" content="见山还是山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="源之居">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/19/20YearsOld/" class="post-title-link" itemprop="url">20岁，我在寻找自己的路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-19 00:46:22" itemprop="dateCreated datePublished" datetime="2022-08-19T00:46:22+08:00">2022-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-30 13:57:17" itemprop="dateModified" datetime="2023-09-30T13:57:17+08:00">2023-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天，是我的生日，农历上的生日。</p>
<p>过去一年，我做了一些改变，也变得更加焦虑和迷茫。</p>
<p>降级转入了物院，从大一重新开始读书，我称之为remake。</p>
<p>学了很多自己喜欢的知识，上着自己喜欢的课程，偶尔会有让我头疼的数学，不过大部分学习时间还是很舒服的。认识了一些很好的朋友，每个周末出去吃饭很是令人愉快。看了一些有意思的书籍，读了很多枯燥的文章，多了一些全新的经历，我的三观在慢慢完善。</p>
<p>22年三月份也就是大一下学期经历了上海疫情，封控，隔离，转运，继续封控。我其实蛮享受被隔离的时光，睡醒开始学习，累了躺着或者玩手机，吃饭洗漱看电影。我在做我自己想做的事情，而不是去上课，去被迫接受知识。那段时光对我来说是很宝贵的，我第一次体会到那样舒服、那样无拘无束的状态。</p>
<p>我阅读了一些对我观念产生很大影响的书籍，《论人类不平等的起源和基础》、《社会契约论》、《资本论》。一些观念被替换被抹去，另一些新的东西在出现。</p>
<p>为了早做打算，我开始认真学习CS方面的知识，从中窥见了和物理不一样的美妙。</p>
<p>我感到迷茫，我要干什么？我的答案是什么？我要去做什么样的事业？我在思考，更多时候在迷茫。就业&#x2F;考研&#x2F;保研&#x2F;出国&#x2F;体制，面对这些选择，面对瞬息万变的形势，我在思考自己的答案是什么。</p>
<p>我感到焦虑，一停下来就会焦虑，焦虑后带来的是放纵，然后就是更深的焦虑……</p>
<p>我似乎不适合工作？几天前接了个线上家教，周一和周五晚上上课，薪资对我来说很好。然而到那一天的时候，脑子里想的都是要怎么才能讲好，怎么才能让学生有提高，明明只有晚上上一个半小时，教课对我来说也很轻松，我却能在白天时不时的担忧好久。 以后可以慢慢适应的吧。</p>
<p>大二想用家教的钱去旅行，想读更多书，想学更多知识，想去实习。</p>
<p>我的十九岁按下了结束键</p>
<p><strong>我的二十岁刚刚开始</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/03/git_often_used/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="FY-Zhu">
      <meta itemprop="description" content="见山还是山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="源之居">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/03/git_often_used/" class="post-title-link" itemprop="url">常用git命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-03 16:02:52" itemprop="dateCreated datePublished" datetime="2022-08-03T16:02:52+08:00">2022-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-19 01:02:58" itemprop="dateModified" datetime="2022-08-19T01:02:58+08:00">2022-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>git –version &#x2F;&#x2F;查看git版本</p>
<p>git config –global user.name 用户名<br>git config –global user.email 用户邮箱<br>&#x2F;&#x2F;设置用户签名 </p>
<p>git init &#x2F;&#x2F;初始化本地库</p>
<p>git status &#x2F;&#x2F;查看本地库状态</p>
<p>git add 文件名  &#x2F;&#x2F;提交到暂存区</p>
<p>git commit -m “日志信息” 文件名 &#x2F;&#x2F;提交到本地库</p>
<p>git reflog  &#x2F;&#x2F;查看历史记录</p>
<p>git log &#x2F;&#x2F;查看详细历史记录</p>
<p>git reset –hard 版本号  &#x2F;&#x2F;版本穿梭</p>
<p>git branch 分支名 &#x2F;&#x2F;创建分支</p>
<p>git branch -v &#x2F;&#x2F;查看分支</p>
<p>git checkout 分支名 &#x2F;&#x2F;切换分支</p>
<p>git merge 分支名  &#x2F;&#x2F;合并分支到当前分支</p>
<blockquote>
<p>分支冲突后，人为修改冲突文件后，git add 文件名，git commuit -m “日志信息” (不带文件名)。</p>
</blockquote>
<p>git remote add 别名 远程https地址  &#x2F;&#x2F;给远程仓库起别名(最好与项目名称一致)</p>
<p>git remote -v &#x2F;&#x2F;查看当前所有远程地址别名</p>
<p>git push 别名 分支 &#x2F;&#x2F;推送本地分支上的内容到远程仓库</p>
<p>git clone 远程地址&#x2F;别名 &#x2F;&#x2F;将远程仓库内容克隆到本地</p>
<p>git pull 远程仓库地址&#x2F;别名 分支名称  &#x2F;&#x2F;将远程仓库分支最新内容拉下来后与本地分支合并</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/30/csapp-note4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="FY-Zhu">
      <meta itemprop="description" content="见山还是山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="源之居">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/30/csapp-note4/" class="post-title-link" itemprop="url">深入理解计算机系统第五章笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 11:38:12" itemprop="dateCreated datePublished" datetime="2022-06-30T11:38:12+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-19 01:59:44" itemprop="dateModified" datetime="2022-08-19T01:59:44+08:00">2022-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>现代编译器已经非常成熟，<del>优化后的代码有时候程序员自己都看不懂</del>。</p>
<p>但是，编译器还是保守，假设你的每个操作都是黑盒子，小心翼翼在不会影响你的操作的前提下进行优化，编译器必须很小心的使用<strong>安全的优化</strong></p>
<h3 id="关于指针的例子"><a href="#关于指针的例子" class="headerlink" title="关于指针的例子"></a>关于指针的例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> *pt1,<span class="type">int</span> *pt2)</span></span>&#123;</span><br><span class="line">    *pt1+=*pt2;</span><br><span class="line">    *pt1+=*pt2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们的本意是 <em>pt1+&#x3D;2</em> (*pt2);这样写更快一点。 </p>
<p>编译器并不会进行这样更快的优化，因为它无法确定 pt1和pt2是否指向内存中相同的位置。它只能假设不同的指针可能会指向内存中的同一位置。</p>
<h2 id="循环中的低效率"><a href="#循环中的低效率" class="headerlink" title="循环中的低效率"></a>循环中的低效率</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> length=<span class="built_in">strlen</span>(s)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次循环都要计算strlen(s) 低效率</p>
<p>假如代码修改了字符串S，编译器并不知道这是否会影响strlen(s)，因此每次都会计算，并不会进行优化。</p>
<h2 id="过程中函数多次调用的低效率"><a href="#过程中函数多次调用的低效率" class="headerlink" title="过程中函数多次调用的低效率"></a>过程中函数多次调用的低效率</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fun1</span>()+<span class="built_in">fun1</span>()+<span class="built_in">fun1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>*<span class="built_in">fun1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们知道fun1()并不会产生副作用，每次调用结果相同，那么test2更加高效。</p>
<p>编译器不能判断fun1()是否会产生副作用，因此不会把test1优化到test2；</p>
<h3 id="inline代替优化函数调用；"><a href="#inline代替优化函数调用；" class="headerlink" title="inline代替优化函数调用；"></a>inline代替优化函数调用；</h3><h2 id="不必要的内存引用"><a href="#不必要的内存引用" class="headerlink" title="不必要的内存引用"></a>不必要的内存引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">b[<span class="number">6</span>]+=a[j];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//优化 </span></span><br><span class="line"><span class="type">int</span> temp=<span class="number">0</span>; <span class="comment">// 优化后 该局部变量被保存在寄存器中，不用一次次的进行内存读写</span></span><br><span class="line"><span class="keyword">for</span>(;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">temp+=a[j];</span><br><span class="line"></span><br><span class="line">b[<span class="number">6</span>]=t;</span><br></pre></td></tr></table></figure>
<p>因为不确定a[j]的变化是否会改变b[6]的数值，因此每次都要从内存读入b[6]，再把更新后的b[6]写进内存,这种内存读写是不必要的，要一次次再内存和寄存器中传送数据。</p>
<p>因为b[6]和a[j]可能指向同一个地址，因此编译器不会进行优化。</p>
<h2 id="流水线处理和并行"><a href="#流水线处理和并行" class="headerlink" title="流水线处理和并行"></a>流水线处理和并行</h2><p>进行循环展开，减少循环迭代次数，提高效率。(减少过程中的索引计算和条件分支，减少计算中关键路径的操作数量)。</p>
<blockquote>
<p>不相关的计算可以进行流水线处理</p>
</blockquote>
<p>循环展开和并行累计多个值一起计算，会提高程序的流水线处理的效率，提高程序并行性。</p>
<p>编译器会自行进行优化，仅作为了解 <del>其实是我现在这部分学的不好</del></p>
<p>下学期 一定要看看 CAAQA 这本经典书</p>
<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p>SRAM(在CPU芯片上) DRAM(主存) 闪存 等等</p>
<p>如何进行内存读写</p>
<blockquote>
<p>cpu将地址传入总线上 发出信号；主存将对应地址的数据x传入总线；cpu 读出数据x 复制到寄存器中。cpu将地址放到总线上，主存读出地址，等待数据字；cpu将数据放到总线上；主存接收数据并且储存到先前指定的地址。 </p>
</blockquote>
<p>磁盘构造，如何进行磁盘读写(指令，逻辑块号，内存地址)</p>
<blockquote>
<p>CPU通知磁盘控制器进行磁盘读写后切换执行其他进程，磁盘写数据到主存中无需CPU操作，写数据结束后 中断 通知CPU。这称为直接内存访问DMA，这种数据传送称为DMA传送</p>
</blockquote>
<p>奇怪的SSD(固态硬盘).</p>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>程序倾向于使用其地址<strong>接近</strong>或者等于最近使用过的数据和指令的地址的那些数据和地址。</p>
<blockquote>
<p>program tend to use data and instructions with addresses near or equal to those they have used recently.</p>
</blockquote>
<p><strong>时间局部性和空间局部性</strong></p>
<p>避免代码出现差的局部性。</p>
<h2 id="缓存不命中的种类"><a href="#缓存不命中的种类" class="headerlink" title="缓存不命中的种类"></a>缓存不命中的种类</h2><p>冷不命中：一个空的缓存称为冷缓存，冷缓存必然不命中，称为冷不命中。</p>
<p>冲突不命中：常用的放置策略是将 k+1 层的某个块限制放置在 k 层块的一个小的子集中。比如 k+1 层的块 1,5,9,13 映射到 k层的块 0。这会带来冲突不命中。</p>
<p>容量不命中：当访问的工作集的大小超过缓存的大小时，会发生容量不命中。即缓存太小了，不能缓存整个工作集。</p>
<h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>最好看书回忆具体步骤</p>
<blockquote>
<p>大概就是，将k个固定大小的字节作为一个整体即“块”，按块储存到高速缓存中，所以要考虑块的大小也会影响到缓存效率（直接映射高速缓存容易引起抖动，例如 <strong>p432的例子</strong>）</p>
</blockquote>
<p>高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程分为三步：</p>
<p>组选择 行匹配 字抽取</p>
<p><strong>具体例子参考 p430</strong></p>
<h2 id="有关写的问题"><a href="#有关写的问题" class="headerlink" title="有关写的问题"></a>有关写的问题</h2><p>写命中（写一个已经缓存了的字 w）的情况下，高速缓存更新了本层的 w 的副本后，如何处理低一层的副本有两种方法：</p>
<ol>
<li><p>直写：立即将 w 的高速缓存块写回到低一层中。   </p>
<ol>
<li>优点：简单</li>
<li>缺点：每次写都会占据总线流量</li>
</ol>
</li>
<li><p>写回：尽可能地推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到低一层中。</p>
<ol>
<li>优点：利用了局部性，可以显著地减少总线流量。</li>
<li>缺点：增加了复杂性。必须为每个高速缓存行维护一个额外的修改位，表明此行是否被修改过。</li>
</ol>
</li>
</ol>
<p>写不命中情况下的两种方法：</p>
<ol>
<li><p>写分配：加载相应的低一层的块到本层中，然后更新这个高速缓存块。</p>
<ol>
<li>优点：利用写的空间局部性</li>
<li>缺点：每次不命中都会导致一个块从低一层传送到高速缓存</li>
</ol>
</li>
<li><p>非写分配：避开高速缓存，直接把这个字写到低一层中</p>
</li>
</ol>
<p>直写一般与非写分配搭配，两者都更适用于存储器层次结构中的较高层。</p>
<p>写回一般与写分配搭配，两者都更适用于存储器层次结构中的较低层，因为较低层的传送时间太长。</p>
<blockquote>
<p>因为硬件上复杂电路的实现越来越容易，所以现在使用写回和写分配越来越多。</p>
</blockquote>
<h2 id="程序中利用局部性"><a href="#程序中利用局部性" class="headerlink" title="程序中利用局部性"></a>程序中利用局部性</h2><p>写完配套的lab就行了</p>
<ol>
<li>注意力集中在内循环中</li>
<li>按照数据对象存储在内存中的数据，按照步长为1来读数据，利用空间局部性</li>
<li>一旦从存储器中读入了一个数据对象，就尽可能多使用它，利用时间局部性</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/28/csapp-note3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="FY-Zhu">
      <meta itemprop="description" content="见山还是山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="源之居">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/28/csapp-note3/" class="post-title-link" itemprop="url">深入理解计算机系统第三章 笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-28 18:36:21" itemprop="dateCreated datePublished" datetime="2022-06-28T18:36:21+08:00">2022-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-19 01:59:51" itemprop="dateModified" datetime="2022-08-19T01:59:51+08:00">2022-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><h2 id="隐藏的东西-in-higher"><a href="#隐藏的东西-in-higher" class="headerlink" title="隐藏的东西 in higher"></a>隐藏的东西 in higher</h2><p>程序计数器PC，寄存器(整数寄存器，浮点数寄存器，条件码寄存器)。寄存器可以操作不储存不同字节大小的数据。</p>
<h2 id="阅读汇编代码"><a href="#阅读汇编代码" class="headerlink" title="阅读汇编代码"></a>阅读汇编代码</h2><p>反汇编得到汇编代码</p>
<p>了解各个指令的具体含义，sub、movb、movzbw、leaq等等。学会阅读不同的操作数格式。</p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>根据条件码寄存器跳转到指定位置，以达到循环语句和判断语句的效果。</p>
<p>switch使用跳转表，根据对应值按照跳转表进行跳转，跳转表对应数值较大时可以进行相应加减运算处理。跳转表范围较大且表项比较稀疏的时候，可以构建二叉树 二分查找。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>全局变量在data区域，代码在text区域，局部变量在stack区域，new、malloc的变量在heap区域。</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>被调用的函数调用结束时，对栈指针进行操作，之后ret弹出返回地址，返回调用函数。</p>
<p>栈帧管理(每一个函数有自己对应的栈帧)，函数在stack上的储存空间 成为过程的栈帧（stack fram），栈帧会保留需要保留的寄存器 以便在函数调用结束后恢复寄存器原有的值（有的寄存器由caller保存 有的由callee保存）。</p>
<p>寄存器不足够存放本地数据、对局部变量进行&amp;运算、局部变量为数组或者结构，此时局部变量必须存放在内存中。</p>
<h2 id="Array-Union-Struct"><a href="#Array-Union-Struct" class="headerlink" title="Array Union Struct"></a>Array Union Struct</h2><p>数组地址顺序排列。结构体地址顺序排列。</p>
<p>Union所占地址空间大小为其中最大的数据所占地址空间，相当于对同一地址空间的不同部分赋予不同的别名，在使用时按照别名进行类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">u</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">&#125;u0;</span><br></pre></td></tr></table></figure>
<p>则 i 为 f底层float表示方法的 十进制数值。</p>
<p>sizeof(u0)&#x3D;4<br>size0f(u0.i)&#x3D;sizeof(u0.f)&#x3D;sizeof(u0)&#x3D;4</p>
<h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><p>任何K字节的基本对象的地址必须是K的倍数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> j;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">&#125;t1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>则 sizeof(t1)&#x3D;12</p>
<p>i占四字节，j占一字节但是j后面三字节为空以达到数据对齐目的，K占四字节 所以共十二字节。</p>
<p>同一类型对象尽量放在一起，节省空间。</p>
<h2 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h2><p>attack lab就是基于缓冲区溢出后 修改返回地址 达到攻击的效果。</p>
<p>C对于数组引用不进行边界检查，局部变量和状态信息都保存在stack 越界引用数组容易修改状态信息（返回地址等）进行破坏。</p>
<p>gets读函数对读入数据大小不进行检查，数据溢出缓冲区会导致stack中信息被破坏。</p>
<h2 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h2><p>写更加strong的代码，进行数据大小检查。</p>
<p>对stack进行破坏检测，存储canary(金丝雀)值(通常该值 末尾以 0 结尾，即使字符数组溢出1位也不影响,因为字符以0结尾，不会修改canary数值，<del>贴心</del>)</p>
<p>stack地址随机化</p>
<p>限制可执行代码区域，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/27/EndExam_Of/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="FY-Zhu">
      <meta itemprop="description" content="见山还是山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="源之居">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/27/EndExam_Of/" class="post-title-link" itemprop="url">关于高考后</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-27 18:20:19" itemprop="dateCreated datePublished" datetime="2022-06-27T18:20:19+08:00">2022-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-19 01:02:32" itemprop="dateModified" datetime="2022-08-19T01:02:32+08:00">2022-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今年一高似乎考的不错。</p>
<p>下午刚睡醒，和同学在群里吹水时说起了今年的高考，我才发现由于取消了提前 交大在我省的分数线降了不少。我高考那一年，是靠着国家专项计划才来了交大，不然只能走提前批，分数不高的人在交大面前没有选择权，于是被调剂。入学没多久，我一直在后悔当时没有去中科大学物理，哪怕后面发现自己适应不了科大物理系的压力，也可以自由转专业。就这样浑浑噩噩的过了一学期，寒假时了解到交大的转专业对提前批有诸多限制，幸运的是我走国家专项计划不受这些限制，大一下我转入了物院。</p>
<p>我对交大是充满感激的，正如我在某个平台上的名字‘remake’,我一直感觉自己的大学因为转专业这个决定被重置了，我的大学生活换了一个方式开始，我很感激交大。</p>
<p>有时候在想，假如当初报了科大或者南大、北航，去学热门专业会怎么样？想了想感觉自己或许会摆烂大学四年。我上大学之前并不是一个自律的人，<del>说得好像我现在是一样</del> 在大学这种自由的环境下，失去了老师的监督，没有面临高考的压力，假如学了CS这些不担心就业的专业，我大概率会跟着培养计划按部就班的摆烂四年。只有经过学化学的磨练，深切体会到英语挂科后的绝望，在挂科后认真思考过自己的出路，<strong>我才明白对于我这样一个背景普通，尚未发现自己有什么天赋的人，学习究竟意味着什么。</strong> </p>
<p>我思想的改变和交大关系很大，<del>毕竟地狱难度的英语期末考试交大是独一份</del> 现在我还后悔来交大吗？后悔被调剂吗？<strong>我不后悔</strong>。</p>
<p>动过去学校门口劝学弟学妹们不要为了<strong>不浪费一分</strong>去盲目冲学校的念头。想了想放弃了，各人有各人的际遇，一年前的我还在后悔来了交大，现在我却为自己感到幸运。再者，高考后的学生观念总是充斥着对于名校的向往 <del>我也向往CMU Stanford</del>，小县城出身的我们即使看了知乎上的言论也大都不会相信专业之间的差距远大于学校，总是以为好学校的专业不会是这样子的，这没办法改变。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/26/leetcode_note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="FY-Zhu">
      <meta itemprop="description" content="见山还是山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="源之居">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/26/leetcode_note/" class="post-title-link" itemprop="url">算法题笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-26 13:45:51" itemprop="dateCreated datePublished" datetime="2022-05-26T13:45:51+08:00">2022-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-19 01:03:08" itemprop="dateModified" datetime="2022-08-19T01:03:08+08:00">2022-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始暑假的集中刷题了，时隔两个月没刷算法，今天发现之前获得的手感和技巧都丧失的差不多了，所以萌生了记笔记的想法。记下一些有价值的题目</p>
<h1 id="LeetCode-Easy"><a href="#LeetCode-Easy" class="headerlink" title="LeetCode Easy"></a>LeetCode Easy</h1><h2 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer 05 替换空格"></a>剑指offer 05 替换空格</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> length=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(length+<span class="number">2</span>*count);</span><br><span class="line">        <span class="type">int</span> old=length<span class="number">-1</span>;<span class="comment">// 从后向前替换 双指针</span></span><br><span class="line">        <span class="type">int</span> n=length+<span class="number">2</span>*count<span class="number">-1</span>;<span class="comment">//n为new </span></span><br><span class="line">        <span class="keyword">while</span>(old&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[old]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s[n--]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[n--]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[n--]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s[n--]=s[old];</span><br><span class="line">            &#125;</span><br><span class="line">            old--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>精髓在于，从后向前替换，而不是从前向后替换，后者做法每次替换都要移动后面元素 o(n^2),前者不需要 o(n);因为  从后向前，n走在old后面(相对于前进方向)，从前向后n在old的前面，s[n]依靠s[old],因此 n应该在old后面。</p>
<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35 搜索插入位置"></a>35 搜索插入位置</h2><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=length<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> now=nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(now&lt;target) left=mid+<span class="number">1</span>; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(now&gt;target) right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> right+<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题目我的犹豫点在于<strong>循环的时候target是否会落在获得的区间之外</strong>，比如[0，100，110，200] target&#x3D;102,第一次迭代后，nums[left]&#x3D;110；target其实在left的左边，因此在二分处理的时候一直思考很多限制，一个简单的Easy题目却想了很多。后来想明白了，我的犹豫点是对的，但是这不影响什么。</p>
<p>这道题目，可以找到和target相等的目标值也就罢了（704题），找不到也就是需要插入的时候，要把target插入在两个数字中间的区域，这种情况下 按照从大到小排序，某次迭代后target一定会落在获得的区间旁边的区域，也就是<strong>right和right+1之间或者left和left-1之间</strong>，此后紧挨着target的区间边界left&#x2F;right不动，另一个边界不断移动，直到 right小于left ,此时迭代终止，而target的位置等于right+1也就是在right和left之间；</p>
<h3 id="二分加暴力"><a href="#二分加暴力" class="headerlink" title="二分加暴力"></a>二分加暴力</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=length<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> temp=right-left;</span><br><span class="line">        <span class="keyword">while</span>(temp&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+temp/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> now=nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(now&lt;target) left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(now&gt;target) right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">            temp=right-left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=target) <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="comment">//这个暴力写法很优雅。</span></span><br><span class="line">        <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仅仅在区间很小的时候采用了暴力，这可能会更高效一点。</p>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27 移除元素"></a>27 移除元素</h2><h3 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]==val) right++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[left]=nums[right];</span><br><span class="line">                left++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本质上是，将两个指针看成在两个相同的数组上操作，而不是一个数组，快指针right将自己所在的数组上的所有不等于val的数值移动到慢指针所在的数组上，(0，right)开区间内的点都!&#x3D;val。</p>
<h3 id="双指针优化-前后双指针"><a href="#双指针优化-前后双指针" class="headerlink" title="双指针优化  前后双指针"></a>双指针优化  前后双指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> right=length<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;=left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[right]!=val)&#123;</span><br><span class="line">                    nums[left]=nums[right];</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用后指针指向的元素替换前指针指向的需要删除的元素，直到两指针相遇后进入最后一次循环。</p>
<h1 id="LeetCode-Mid"><a href="#LeetCode-Mid" class="headerlink" title="LeetCode Mid"></a>LeetCode Mid</h1><h2 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59 螺旋矩阵||"></a>59 螺旋矩阵||</h2><h3 id="便于理解带注释"><a href="#便于理解带注释" class="headerlink" title="便于理解带注释"></a>便于理解带注释</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop_times = n / <span class="number">2</span>; <span class="comment">// 一圈处理两层，需要循环几圈，例如n为奇数3，那么loop_times = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 每一圈循环，需要控制每一条边遍历的长度</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop_times --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;<span class="comment">//竖着为x 横着为y  y轴上是同一个一维数组的。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; starty + n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; startx + n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="习惯写法"><a href="#习惯写法" class="headerlink" title="习惯写法"></a>习惯写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">answer</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> loop_times=n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> end=n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> start_x=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start_y=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> number=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cut_length=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="keyword">while</span>(loop_times--)&#123;</span><br><span class="line">            x=start_x;</span><br><span class="line">            y=start_y;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(;y&lt;n-cut_length;y++)&#123;</span><br><span class="line">                answer[x][y]=number++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;x&lt;n-cut_length;x++)&#123;</span><br><span class="line">                answer[x][y]=number++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;y&gt;cut_length<span class="number">-1</span>;y--)&#123;</span><br><span class="line">                answer[x][y]=number++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;x&gt;cut_length<span class="number">-1</span>;x--)&#123;</span><br><span class="line">                answer[x][y]=number++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            start_x++;</span><br><span class="line">            start_y++;</span><br><span class="line">            cut_length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>)&#123;</span><br><span class="line">            answer[end][end]=number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道模拟有点意思，像这种模拟我一直不太在行，打印乘法表这种大一C++作业题我都有点怵，菜鸡本菜了。</p>
<h2 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="142 环形链表||"></a>142 环形链表||</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow=head;</span><br><span class="line">        ListNode* fast=head;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next-&gt;next; </span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;slow!=fast)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;<span class="comment">//fast指针经过的长度 是 slow经过的长度的 2 倍数</span></span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>||fast-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        slow=head; <span class="comment">//slow从头节点开始 fast从两者在环上相遇的位置开始 两者到入口处长度相等(解方程可得该信息</span></span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经典快慢指针做法，后面找环入口用到简单的数学知识。应该设长度，而不是节点数目。</p>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15 三数之和"></a>15 三数之和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; answer;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;<span class="number">3</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur=<span class="number">0</span>;cur&lt;length;cur++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[cur]&gt;<span class="number">0</span>) <span class="keyword">return</span> answer;</span><br><span class="line">            <span class="type">int</span> left=cur+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right=length<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur&gt;<span class="number">0</span>&amp;&amp;nums[cur]==nums[cur<span class="number">-1</span>]) <span class="keyword">continue</span>;<span class="comment">// 避免排除 -1 -1 2 这种正确情况 cur 在重复序列的第一个</span></span><br><span class="line">            <span class="comment">// cur重复且nums[cur]对应有正确结果 则会出现重复答案，cur不重复且固定 只考虑left重复，结果一样，cur left 不重复且固定，只考虑right重复，结果也可能重复。</span></span><br><span class="line">            <span class="comment">// 故三种情况均需要去重  </span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(nums[cur]+nums[right]+nums[left]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    right--;<span class="comment">//nums[right] 变为新的数值，但在right=length-1或者上一个判断循环满足三者相加等于0时，不一定变为新的数值，在下一次循环时候才会变化</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right+<span class="number">1</span>]) right--;<span class="comment">// right位置移动到 (新的)重复的序列的 第一个位置，若为最后一个位置，则排除了nums[right]==nums[left]的正确结果</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[cur]+nums[right]+nums[left]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left<span class="number">-1</span>]) left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    answer.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[cur],nums[left],nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right<span class="number">-1</span>]) right--;<span class="comment">// 去掉right重复，right移动到重复序列的最后一个位置,此时为最后一个是因为 已经符合结果 需要更新数值避免重复。</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    </span><br><span class="line">                    right--; <span class="comment">//nums[right]变为新的数值 </span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>双指针，去重麻烦。</p>
<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">	    <span class="comment">// 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; (nums[k] &gt;= <span class="number">0</span> || target &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            	<span class="keyword">break</span>; <span class="comment">// 这里使用break，跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 去重 k移动到新的重复序列的最左端 nums[k] 更新, 并且避免排除 -1 -1 -1 3 target为0的正确答案</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	    	<span class="comment">// 2级剪枝处理</span></span><br><span class="line">		        <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; (nums[k] + nums[i] &gt;= <span class="number">0</span> || target &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		            <span class="keyword">break</span>; <span class="comment">// 跳出 二级循环</span></span><br><span class="line">		        &#125;</span><br><span class="line">		</span><br><span class="line">                <span class="comment">// 正确去重方法</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[k] + nums[i] &gt; target - (nums[left] + nums[right])) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                        <span class="comment">// 当前元素不合适了，可以去重，right移动到新的重复序列的最右端，nums[right]更新</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] + nums[i]  &lt; target - (nums[left] + nums[right])) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="comment">// 不合适，去重</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 去重逻辑应该放在找到一个四元组之后</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;<span class="comment">// right移动到旧重复序列的最左端</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;<span class="comment">//此时nums[right]才更新</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>经典，需要背诵(×</p>
<h2 id="151-颠倒字符串单词"><a href="#151-颠倒字符串单词" class="headerlink" title="151 颠倒字符串单词"></a>151 颠倒字符串单词</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;end)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[begin++],s[end--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 翻转函数 左闭右闭</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(s[<span class="number">0</span>]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="comment">// 清除前面的空格</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(s[s.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="comment">// 清除后面空格</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length=s.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(s,<span class="number">0</span>,length<span class="number">-1</span>); <span class="comment">// 整体字符串翻转</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur&lt;s.<span class="built_in">size</span>())&#123; <span class="comment">// 删除空格导致size动态变化 所以用s.size() 随时更新 而不是固定的数值</span></span><br><span class="line">            <span class="keyword">if</span>(s[cur]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,slow,cur<span class="number">-1</span>); <span class="comment">// 局部单词内部翻转</span></span><br><span class="line">                slow=cur+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur==s.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">reverse</span>(s,slow,cur); <span class="comment">// 局部最后一个单词翻转</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(s[slow]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+slow);</span><br><span class="line">            &#125;<span class="comment">// 清除单词之间多余的空格</span></span><br><span class="line">            </span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>巧妙之处在于，<strong>先整体翻转 后 局部反转</strong>，改变了单词的位置顺序 而 不改变单词内部的字母顺序。</p>
<p>不足之处在于，reverse时间复杂度为o(n)，加上外面循环o(n),一共为o(n^2)，优化的话可以采用<strong>双指针</strong>，提前清除所有多余空格，时间复杂度为o(n)，代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> length=s.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> slow=<span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> fast=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(fast&lt;length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[fast]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(slow!=<span class="number">0</span>&amp;&amp;s[slow<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>) slow--;</span><br><span class="line">        s[slow]=s[fast]; <span class="comment">// 无法去除两端的空格，两侧存在至多一个空格。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s[slow]=s[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    slow++;</span><br><span class="line">    fast++; <span class="comment">// slow 和 fast 处理也巧妙，夸我一句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s[slow<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>) s.<span class="built_in">resize</span>(slow<span class="number">-1</span>);<span class="comment">// 去除后面多余的一个空格</span></span><br><span class="line"><span class="keyword">else</span> s.<span class="built_in">resize</span>(slow);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27; &#x27;</span>) s.<span class="built_in">erase</span>(s.<span class="built_in">beigin</span>());</span><br></pre></td></tr></table></figure>
<p>清除空格 时间复杂度o(n) </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">FY-Zhu</p>
  <div class="site-description" itemprop="description">见山还是山</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FY-Zhu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
